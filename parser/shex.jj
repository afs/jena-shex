/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options
{
       JAVA_UNICODE_ESCAPE   = false ;
       //??
       UNICODE_INPUT         = true ;

  STATIC                = false ;
//  DEBUG_PARSER          = true ;
//  DEBUG_TOKEN_MANAGER   = true ;
}

PARSER_BEGIN(ShExJavacc)
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package shex.parser.javacc;

import shex.parser.*;
//import org.apache.jena.sparql.path.*;

public class ShExJavacc extends ShExBase
{}
PARSER_END(ShExJavacc)

void Unit(): { }
{
  (<BOM>)?
  shexDoc()
  <EOF>
}

void shexDoc() : {}
{
  (directive())*
}

void directive() : {}
{
  ( baseDecl() | prefixDecl() | importDecl() )
}

void baseDecl() : { String iri ; }
{
  <BASE> iri = IRIREF()
//  { getPrologue().setBaseURI(iri) ; }
}

void prefixDecl() : { Token t ; String iri ; }
{
    <PREFIX> t = <PNAME_NS> iri = IRIREF()
//      { String s = fixupPrefix(t.image, t.beginLine, t.beginColumn) ;
//        getPrologue().setPrefix(s, iri) ; }
}

void importDecl() : { String iri ; }
{
  <IMPORTS> iri = iri()
  //{ getPrologue().setBaseURI(iri) ; }
}

void notStartAction() : {}
{
    start() | shapeExprDecl()
}

void start() : { }
{
    <START> <EQUALS> inlineShapeExpression()
}

void startActions() : {}
{
    (codeDecl())+
}

void statement() : {}
{
	directive() | notStartAction()
}

void shapeExprDecl() : { }
{
    shapeExprLabel() (shapeExpression() | <EXTERNAL>)
}

void shapeExpression() : { }
{
    shapeOr()
}

void inlineShapeExpression() : {}
{
	inlineShapeOr()
}

void shapeOr() : {}
{
    shapeAnd() (<OR> shapeAnd())*
}

void inlineShapeOr() : {}
{
    inlineShapeAnd() (<OR> inlineShapeAnd())*
}

void shapeAnd() : { }
{
    shapeNot() (<AND> shapeNot())*
}


void inlineShapeAnd() : { }
{
    inlineShapeNot() (<AND> inlineShapeNot())*
}


void shapeNot() : { }
{
    (<NOT>)? shapeAtom()
}

void inlineShapeNot() : { }
{
    (<NOT>)? inlineShapeAtom()
}

void shapeAtom() : {}
{
    nonLitNodeConstraint() (shapeOrRef())?
  | litNodeConstraint()
  | shapeOrRef() (nonLitNodeConstraint())?
  | <LPAREN> shapeExpression() <RPAREN>
  | <DOT>
}

void shapeAtomNoRef() : {}
{
    nonLitNodeConstraint() (shapeOrRef())?
  | litNodeConstraint()
  | shapeDefinition() (nonLitNodeConstraint())?
  | <LPAREN> shapeExpression() <RPAREN>
  | <DOT>
}

void inlineShapeAtom() : {}
{
    nonLitNodeConstraint () (inlineShapeOrRef())?
  | litNodeConstraint()
  | inlineShapeOrRef() (nonLitNodeConstraint())?
  | <LPAREN> shapeExpression() <RPAREN>
  | <DOT>
}


void shapeOrRef() : {}
{
    shapeDefinition() | shapeRef()
}

void inlineShapeOrRef() : {}
{
    inlineShapeDefinition () | shapeRef()
}

void shapeRef() : {}
{
    <ATPNAME_LN> | <ATPNAME_NS> | <AT> shapeExprLabel()
}

void litNodeConstraint() : {} {
    <LITERAL>  (xsFacet())*
  | datatype() (xsFacet())*
  | valueSet() (xsFacet())*
  | (numericFacet())+
}

// Check precedence

void nonLitNodeConstraint() : {} {
    nonLiteralKind() (stringFacet())*
  | (stringFacet())+
}

void nonLiteralKind() : {} {
    <IRI> | <BNODE> | <NONLITERAL>
}

void xsFacet() : { }
{
    stringFacet() | numericFacet()
}

void stringFacet() : { }
{
    stringLength() <INTEGER> 
  | <REGEXP>
}

void stringLength() : { }
{
     <LENGTH> | <MINLENGTH> | <MAXLENGTH>
}

void numericFacet() : { }
{
    numericRange() numericLiteral()
  | numericLength() <INTEGER>
}

void numericRange() : { }
{
    <MININCLUSIVE> | <MINEXCLUSIVE> | <MAXINCLUSIVE> | <MAXEXCLUSIVE>
}

void numericLength() : { }
{
     <TOTALDIGITS> | <FRACTIONDIGITS>
}

void shapeDefinition() : {}
{
 	(extraPropertySet() | <CLOSED>)*
    <LBRACE> (tripleExpression())? <RBRACE>
    (annotation())*
    semanticActions()
}

void inlineShapeDefinition() : {}
{
   	(extraPropertySet() | <CLOSED>)*
    <LBRACE> (tripleExpression())? <RBRACE>
}

void extraPropertySet() : {}
{
   	<EXTRA> (predicate())+
}

void tripleExpression() : {}
{
 	oneOfTripleExpr()
}

void oneOfTripleExpr() : {}
{
//  	groupTripleExpr() | multiElementOneOf()
     multiElementOneOf()
}

void multiElementOneOf() : {}
{
   	groupTripleExpr() (<VBAR> groupTripleExpr())+
}

void groupTripleExpr() : {}
{
//   	singleElementGroup() | multiElementGroup()
    multiElementGroup()
}

// void singleElementGroup() : {}
// {
//   	unaryTripleExpr() (<SEMI_COLON>)?
// }

void multiElementGroup() : {}
{
  	unaryTripleExpr() ( LOOKAHEAD(2) <SEMI_COLON> unaryTripleExpr())+ (<SEMI_COLON>)?
}

void unaryTripleExpr() : {}
{
   (<DOLLAR> tripleExprLabel())? (tripleConstraint() | bracketedTripleExpr())
}

void bracketedTripleExpr(): { }
{
   	<LPAREN> tripleExpression() <RPAREN>
    (cardinality())?
    (annotation())*
    semanticActions()
}

void tripleConstraint() : {}
{
  	(senseFlags())? predicate() inlineShapeExpression() (cardinality())? (annotation())* semanticActions()
}

void cardinality() : {}
{
   	<STAR> | <PLUS>| <QMARK> | <REPEAT_RANGE>
}

void senseFlags() : {}
{
  	<CARAT>
}

void valueSet() : {}
{
  	<LBRACKET> (valueSetValue())* <RBRACKET>
}

void valueSetValue() : {}
{
    iriRange() | literalRange() | languageRange() | (LOOKAHEAD(2) exclusion())+
}

void exclusion() : {}
{
  	<MINUS>
    (
        LOOKAHEAD(2)
        iri() | literal() | <LANGTAG>
    ) (<TILDE>)?
}

// ---- HERE ----


void iriRange() : {}
{
   iri() (<TILDE> (LOOKAHEAD(2) exclusion())*)?
}


void iriExclusion() : {}
{
    <MINUS> iri() (<TILDE>)?
}

void literalRange() : {}
{
    literal() (<TILDE> ( LOOKAHEAD(2) literalExclusion())*)?
}

void literalExclusion() : {}
{
    <MINUS> literal() (<TILDE>)?
}

void languageRange() : {}
{
    (
    <LANGTAG> (<TILDE> ( LOOKAHEAD(2) languageExclusion())*)?
    |
    <AT> <TILDE> ( LOOKAHEAD(2) languageExclusion())*
    )
}

void languageExclusion() : {}
{
    <MINUS> <LANGTAG> (<TILDE>)?
}

void include() : {}
{
     <AMP> tripleExprLabel()
}

void annotation() : {}
{
    "//" predicate() (iri() | literal())
}

void semanticActions() : {}
{
    (codeDecl())*
}

void codeDecl() : {}
{
    <PERCENT_CHAR> iri() (<CODE> | <PERCENT_CHAR> )
}

void literal() : {}
{
  rdfLiteral() | numericLiteral() | booleanLiteral()
}

void predicate() : {}
{
    iri() | <RDF_TYPE>
}

// void datatype() : {}
// {
//     iri()
// }

void shapeExprLabel() : {}
{
    iri() | blankNode()
}

void tripleExprLabel() : {}
{
    iri() | blankNode()
}



// ------------------------- Terms

void booleanLiteral():{}{ <TRUE> | <FALSE> }

void numericLiteral():{}{ <INTEGER> | <DECIMAL> | <DOUBLE> }

void rdfLiteral():{} {
    langString() | string() ("^^" datatype())?
}

void datatype():{} { iri() }

void string():{}
{
   <STRING_LITERAL_LONG1> | <STRING_LITERAL_LONG2> | <STRING_LITERAL1> | <STRING_LITERAL2>
}

void langString():{}
{
    <LANG_STRING_LITERAL1> | <LANG_STRING_LITERAL_LONG1>
  | <LANG_STRING_LITERAL2> | <LANG_STRING_LITERAL_LONG2>
}

String iri() : { String iri = null; }
{
  iri = IRIREF() { return iri ; }
|
  iri = prefixedName() { return iri ; }
}

void blankNode() : {}
{
    <BLANK_NODE_LABEL>
}

String prefixedName() : { Token t ; }
{
  ( t = <PNAME_LN>
//    { return resolvePName(t.image, t.beginLine, t.beginColumn) ; }
  |
    t = <PNAME_NS>
//    { return resolvePName(t.image, t.beginLine, t.beginColumn) ; }
  )
  { return null; }
}

String IRIREF() : { Token t ; }
{
  t = <IRIref>
//  { return resolveQuotedIRI(t.image, t.beginLine, t.beginColumn) ; }
  { return null; }
}


SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

SPECIAL_TOKEN :
{ <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }

TOKEN: { 
  <BOM:    "\uFEFF">
}

TOKEN [IGNORE_CASE] :
{
  // Keywords
  <BASE             : "BASE" >
| <IMPORTS          : "IMPORTS">
| <PREFIX           : "PREFIX">

| <SHAPE_CLASS      : "shapeClass">
| <SHAPE            : "shape">
| <START            : "start">
| <EXTERNAL         : "external">

| <NOT              : "not">
| <OR               : "or" >
| <AND              : "and" >

| <LITERAL          : "literal">
| <IRI              : "iri" >
| <BNODE            : "bnode" >
| <NONLITERAL       : "nonliteral" >

| <LENGTH           : "length" >
| <MINLENGTH        : "minlength" >
| <MAXLENGTH        : "maxlength" >
| <MININCLUSIVE     : "mininclusive" >
| <MINEXCLUSIVE     : "minexclusive" >
| <MAXINCLUSIVE     : "maxinclusive" >
| <MAXEXCLUSIVE     : "maxexclusive" >
| <TOTALDIGITS      : "totaldigits" >
| <FRACTIONDIGITS   : "fractiondigits" >

| <CLOSED           : "closed" >
| <EXTRA            : "extra" >
| <RDF_TYPE         : "a" >

| <CODE             : "{" (~[ "%","\\"] | "\\" ["%","\\"] | <UCHAR>)* "%" "}" >
// Why is this a token?
| <REPEAT_RANGE	    : <LBRACE> <INTEGER> ( <COMMA> (<INTEGER> | <STAR> )? )? <RBRACE> >

| <TRUE             : "true">
| <FALSE            : "false">
| <#HEX                : ["0"-"9"] | ["A"-"F"] | ["a"-"f"] >
| <PLUS                : "+" >
| <MINUS               : "-" >
| <VBAR                : "|" >
| <AT                  : "@">
| <CARAT               : "^">
| <DOT                 : ".">
| <BANG                : "!">
| <QMARK               : "?">
| <SLASH               : "/">
| <STAR                : "*">
| <EQUALS              : "=">
| <LPAREN              : "(" >
| <RPAREN              : ")" >
| <LBRACE              : "{" >
| <RBRACE              : "}" >
| <LBRACKET            : "[" >
| <RBRACKET            : "]" >
| <PERCENT_CHAR        : "%" >
| <COMMA               : "," >
| <COLON               : ":" >
| <SEMI_COLON          : ";" >
| <DOLLAR              : "$" >
| <TILDE               : "~" >
| <AMP                 : "&" >

| <#UCHAR              : "\\" ( "u" <HEX> <HEX> <HEX> <HEX> | "U" <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> ) >
| <IRIref              : "<"
                           (~[ ">","<", "\"", "{", "}", "^", "\\", "|", "`","\u0000"-"\u0020"] | <UCHAR>)*
                         ">" >
| <PNAME_NS            : (<PN_PREFIX>)? ":" >
| <PNAME_LN            : <PNAME_NS> <PN_LOCAL> >

| <ATPNAME_NS          : <AT><PNAME_LN> >
| <ATPNAME_LN          : <AT><PNAME_NS> >

| <#QUOTE_3D: "\"\"\"">
| <#QUOTE_3S: "'''">
| <ECHAR : "\\" ( "t"|"b"|"n"|"r"|"f"|"\\"|"\""|"'") >

| <STRING_LITERAL1: 
      // Single quoted string
      "'" ( (~["'","\\","\n","\r"]) | <ECHAR> | <UCHAR> )* "'" > 
| <STRING_LITERAL2:
    // Double quoted string
      "\"" ( (~["\"","\\","\n","\r"]) | <ECHAR>  | <UCHAR> )* "\"" >
| <STRING_LITERAL_LONG1:
     <QUOTE_3S> 
      ( ("'" | "''")? (~["'","\\"] | <ECHAR>  | <UCHAR> ))*
     <QUOTE_3S> >
| <STRING_LITERAL_LONG2: 
     <QUOTE_3D> 
      ( ("\"" | "\"\"")? (~["\"","\\"] | <ECHAR> | <UCHAR>))*
     <QUOTE_3D> >

| <LANG_STRING_LITERAL1       : <STRING_LITERAL1> <LANGTAG> >
| <LANG_STRING_LITERAL2       : <STRING_LITERAL2> <LANGTAG> >
| <LANG_STRING_LITERAL_LONG1  : <STRING_LITERAL_LONG1> <LANGTAG> >
| <LANG_STRING_LITERAL_LONG2  : <STRING_LITERAL_LONG2> <LANGTAG> >

| <#DIGITS             : (["0"-"9"])+>
| <INTEGER             : (<PLUS>|<MINUS>)? <DIGITS> >
| <DECIMAL             : (<PLUS>|<MINUS>)? (<DIGITS>)? "." <DIGITS> >
| <DOUBLE              : (<PLUS>|<MINUS>)?
                          ( (["0"-"9"])+ "." (["0"-"9"])* <EXPONENT>
                          | "." (["0"-"9"])+ (<EXPONENT>)
                          | (["0"-"9"])+ <EXPONENT>
                          ) >
    
| <#EXPONENT           : ["e","E"] (["+","-"])? (["0"-"9"])+ >


| <REGEXP              :    <SLASH>
                            ( ~["/","\\","\n", "\r"]
                            | "\\" [ "n", "r", "t", "\\", "|", "." , "?", "*", "+",
                                    "(", ")", "{", "}", "$", "-", "[", "]", "^", "/" ]
                            | <UCHAR>
                            )+ <SLASH> (["s","m","i","x"])*
                          >
| <BLANK_NODE_LABEL: "_:" (<PN_CHARS_U> | ["0"-"9"]) ((<PN_CHARS> | ".")* <PN_CHARS>)? >
| <LANGTAG: <AT> (<A2Z>)+("-" (<A2ZN>)+)* >
| <#A2Z: ["a"-"z","A"-"Z"]>
| <#A2ZN: ["a"-"z","A"-"Z","0"-"9"]>
| <#PN_CHARS_BASE:
          ["A"-"Z"] | ["a"-"z"] |
          ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] | ["\u00F8"-"\u02FF"] |
          ["\u0370"-"\u037D"] | ["\u037F"-"\u1FFF"] |
          ["\u200C"-"\u200D"] | ["\u2070"-"\u218F"] | ["\u2C00"-"\u2FEF"] |
          ["\u3001"-"\uD7FF"] | ["\uF900"-"\uFFFD"] 
          >
          // [#x10000-#xEFFFF]
|
  // With underscore
  <#PN_CHARS_U: <PN_CHARS_BASE> | "_" >
|
  <#PN_CHARS: (<PN_CHARS_U> | "-" | ["0"-"9"] | "\u00B7" |
              ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] ) >
|
  // No leading "_", no trailing ".", can have dot inside prefix name.
  <#PN_PREFIX: <PN_CHARS_BASE> ((<PN_CHARS>|".")* <PN_CHARS>)?  >
|
  <#PN_LOCAL: (<PN_CHARS_U> | ":" | ["0"-"9"] | <PLX> ) 
              ( (<PN_CHARS> | "." |":" | <PLX> )* 
                (<PN_CHARS> | ":" | <PLX>) )?  >
|
  <#VARNAME: ( <PN_CHARS_U> | ["0"-"9"] )
             ( <PN_CHARS_U> | ["0"-"9"] | "\u00B7" |
               ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] )* >
|
  < #PN_LOCAL_ESC: "\\" 
          ( "_" | 
            "~" | "." | "-" | "!" | "$" | "&" | "'" | 
           "(" | ")" | "*" | "+" | "," | ";" | "=" | 
           "/" | "?" | "#" | "@" | "%" ) >
|
  <#PLX:  <PERCENT> | <PN_LOCAL_ESC> >
|
  <#PERCENT : "%" <HEX> <HEX> >
}

// Catch-all tokens.  Must be last.  
// Any non-whitespace.  Causes a parser exception, rather than a
// token manager error (which hides the line numbers).
TOKEN:
{
  <#UNKNOWN: (~[" ","\t","\n","\r","\f" ])+ >
}


/*
# Local Variables:
# tab-width: 4
# indent-tabs-mode: nil
# comment-default-style: "//"
# End:
*/
