
DOCUMENT START
TOKENS
<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
}

// SPECIAL_TOKEN :
// { <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }


// Comments.
<DEFAULT> SKIP : {
<"#" (~["\r","\n"])*>
| "/*" : ML_COMMENT_STATE
}

<ML_COMMENT_STATE> SKIP : {
"*/" : DEFAULT
| <~[]>
}

// // C-style comments (they don't nest /* /*...*/ */ is a syntax error)
// // When a /* is seen in the DEFAULT state, skip it and switch to the IN_COMMENT state
// SKIP : { "/*": IN_COMMENT }
//       
// // When any other character is seen in the IN_COMMENT state, skip it.
// < IN_COMMENT > SKIP : { < ~[] > }
//       
// // When a */ is seen in the IN_COMMENT state, skip it and switch back to the DEFAULT state
// < IN_COMMENT > SKIP : { "*/": DEFAULT } 
<DEFAULT> TOKEN : {
<BOM: "\ufeff">
}

<DEFAULT> TOKEN [IGNORE_CASE] : {
<BASE: "BASE">
| <IMPORT: "IMPORT">
| <PREFIX: "PREFIX">
| <SHAPE_CLASS: "shapeClass">
| <SHAPE: "shape">
| <START: "start">
| <EXTERNAL: "external">
| <NOT: "not">
| <OR: "or">
| <AND: "and">
| <LITERAL: "literal">
| <IRI: "iri">
| <BNODE: "bnode">
| <NONLITERAL: "nonliteral">
| <LENGTH: "length">
| <MINLENGTH: "minlength">
| <MAXLENGTH: "maxlength">
| <MININCLUSIVE: "mininclusive">
| <MINEXCLUSIVE: "minexclusive">
| <MAXINCLUSIVE: "maxinclusive">
| <MAXEXCLUSIVE: "maxexclusive">
| <TOTALDIGITS: "totaldigits">
| <FRACTIONDIGITS: "fractiondigits">
| <CLOSED: "closed">
| <EXTRA: "extra">
| <RDF_TYPE: "a">
| <CODE: "{" (~["%","\\"] | "\\" ["%","\\"] | <UCHAR>)* "%" "}">
| <REPEAT_RANGE: <LBRACE> <INTEGER> (<COMMA> (<INTEGER> | <STAR>)?)? <RBRACE>>
| <TRUE: "true">
| <FALSE: "false">
| <#HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
| <PLUS: "+">
| <MINUS: "-">
| <VBAR: "|">
| <AT: "@">
| <CARAT: "^">
| <DOT: ".">
| <BANG: "!">
| <QMARK: "?">
| <SLASH: "/">
| <STAR: "*">
| <EQUALS: "=">
| <LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <PERCENT_CHAR: "%">
| <COMMA: ",">
| <SEMI_COLON: ";">
| <DOLLAR: "$">
| <TILDE: "~">
| <AMP: "&">
| <#UCHAR: "\\" ("u" <HEX> <HEX> <HEX> <HEX> | "U" <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> <HEX>)>
| <IRIref: "<" (~[">","<","\"","{","}","^","\\","|","`","\u0000"-" "] | <UCHAR>)* ">">
| <PNAME_NS: (<PN_PREFIX>)? ":">
| <PNAME_LN: <PNAME_NS> <PN_LOCAL>>
| <ATPNAME_NS: <AT> <PNAME_LN>>
| <ATPNAME_LN: <AT> <PNAME_NS>>
| <#QUOTE_3D: "\"\"\"">
| <#QUOTE_3S: "\'\'\'">
| <ECHAR: "\\" ("t" | "b" | "n" | "r" | "f" | "\\" | "\"" | "\'")>
| <STRING_LITERAL1: "\'" (~["\'","\\","\n","\r"] | <ECHAR> | <UCHAR>)* "\'">
| <STRING_LITERAL2: "\"" (~["\"","\\","\n","\r"] | <ECHAR> | <UCHAR>)* "\"">
| <STRING_LITERAL_LONG1: <QUOTE_3S> (("\'" | "\'\'")? (~["\'","\\"] | <ECHAR> | <UCHAR>))* <QUOTE_3S>>
| <STRING_LITERAL_LONG2: <QUOTE_3D> (("\"" | "\"\"")? (~["\"","\\"] | <ECHAR> | <UCHAR>))* <QUOTE_3D>>
| <LANG_STRING_LITERAL1: <STRING_LITERAL1> <LANGTAG>>
| <LANG_STRING_LITERAL2: <STRING_LITERAL2> <LANGTAG>>
| <LANG_STRING_LITERAL_LONG1: <STRING_LITERAL_LONG1> <LANGTAG>>
| <LANG_STRING_LITERAL_LONG2: <STRING_LITERAL_LONG2> <LANGTAG>>
| <#DIGITS: (["0"-"9"])+>
| <INTEGER: (<PLUS> | <MINUS>)? <DIGITS>>
| <DECIMAL: (<PLUS> | <MINUS>)? (<DIGITS>)? "." <DIGITS>>
| <DOUBLE: (<PLUS> | <MINUS>)? ((["0"-"9"])+ "." (["0"-"9"])* <EXPONENT> | "." (["0"-"9"])+ <EXPONENT> | (["0"-"9"])+ <EXPONENT>)>
| <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
| <REGEXP: <SLASH> (~["/","\\","\n","\r"] | "\\" ["n","r","t","\\","|",".","?","*","+","(",")","{","}","$","-","[","]","^","/"] | <UCHAR>)+ <SLASH> (["s","m","i","x"])*>
| <BLANK_NODE_LABEL: "_:" (<PN_CHARS_U> | ["0"-"9"]) ((<PN_CHARS> | ".")* <PN_CHARS>)?>
| <LANGTAG: <AT> (<A2Z>)+ ("-" (<A2ZN>)+)*>
| <#A2Z: ["a"-"z","A"-"Z"]>
| <#A2ZN: ["a"-"z","A"-"Z","0"-"9"]>
| <#PN_CHARS_BASE: ["A"-"Z"] | ["a"-"z"] | ["\u00c0"-"\u00d6"] | ["\u00d8"-"\u00f6"] | ["\u00f8"-"\u02ff"] | ["\u0370"-"\u037d"] | ["\u037f"-"\u1fff"] | ["\u200c"-"\u200d"] | ["\u2070"-"\u218f"] | ["\u2c00"-"\u2fef"] | ["\u3001"-"\ud7ff"] | ["\uf900"-"\ufffd"]>
| <#PN_CHARS_U: <PN_CHARS_BASE> | "_">
| <#PN_CHARS: <PN_CHARS_U> | "-" | ["0"-"9"] | "\u00b7" | ["\u0300"-"\u036f"] | ["\u203f"-"\u2040"]>
| <#PN_PREFIX: <PN_CHARS_BASE> ((<PN_CHARS> | ".")* <PN_CHARS>)?>
| <#PN_LOCAL: (<PN_CHARS_U> | ":" | ["0"-"9"] | <PLX>) ((<PN_CHARS> | "." | ":" | <PLX>)* (<PN_CHARS> | ":" | <PLX>))?>
| <#VARNAME: (<PN_CHARS_U> | ["0"-"9"]) (<PN_CHARS_U> | ["0"-"9"] | "\u00b7" | ["\u0300"-"\u036f"] | ["\u203f"-"\u2040"])*>
| <#PN_LOCAL_ESC: "\\" ("_" | "~" | "." | "-" | "!" | "$" | "&" | "\'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%")>
| <#PLX: <PERCENT> | <PN_LOCAL_ESC>>
| <#PERCENT: "%" <HEX> <HEX>>
}

// Catch-all tokens.  Must be last.  
// Any non-whitespace.  Causes a parser exception, rather than a
// token manager error (which hides the line numbers).
<DEFAULT> TOKEN : {
<#UNKNOWN: (~[" ","\t","\n","\r","\f"])+>
}

NON-TERMINALS
	Unit	:=	( <BOM> )? shexDoc <EOF>
	shexDoc	:=	( directive )* ( ( notStartAction | startActions ) ( statement )* )?
	directive	:=	( baseDecl | prefixDecl | importDecl )
	baseDecl	:=	<BASE> IRIREF
	prefixDecl	:=	<PREFIX> <PNAME_NS> IRIREF
	importDecl	:=	<IMPORT> iri
	notStartAction	:=	start
		|	shapeExprDecl
	start	:=	<START> <EQUALS> inlineShapeExpression
	startActions	:=	( codeDecl )+
	statement	:=	directive
		|	notStartAction
	shapeExprDecl	:=	shapeExprLabel ( shapeExpression | <EXTERNAL> )
	shapeExpression	:=	shapeOr
	inlineShapeExpression	:=	inlineShapeOr
	shapeOr	:=	shapeAnd ( <OR> shapeAnd )*
	inlineShapeOr	:=	inlineShapeAnd ( <OR> inlineShapeAnd )*
	shapeAnd	:=	shapeNot ( <AND> shapeNot )*
	inlineShapeAnd	:=	inlineShapeNot ( <AND> inlineShapeNot )*
	shapeNot	:=	( <NOT> )? shapeAtom
	inlineShapeNot	:=	( <NOT> )? inlineShapeAtom
	shapeAtom	:=	nonLitNodeConstraint ( shapeOrRef )?
		|	litNodeConstraint
		|	shapeOrRef ( nonLitNodeConstraint )?
		|	<LPAREN> shapeExpression <RPAREN>
		|	<DOT>
	shapeAtomNoRef	:=	nonLitNodeConstraint ( shapeOrRef )?
		|	litNodeConstraint
		|	shapeDefinition ( nonLitNodeConstraint )?
		|	<LPAREN> shapeExpression <RPAREN>
		|	<DOT>
	inlineShapeAtom	:=	nonLitNodeConstraint ( inlineShapeOrRef )?
		|	litNodeConstraint
		|	inlineShapeOrRef ( nonLitNodeConstraint )?
		|	<LPAREN> shapeExpression <RPAREN>
		|	<DOT>
	shapeOrRef	:=	shapeDefinition
		|	shapeRef
	inlineShapeOrRef	:=	inlineShapeDefinition
		|	shapeRef
	shapeRef	:=	<ATPNAME_LN>
		|	<ATPNAME_NS>
		|	<AT> shapeExprLabel
	litNodeConstraint	:=	<LITERAL> ( xsFacet )*
		|	datatype ( xsFacet )*
		|	valueSet ( xsFacet )*
		|	( numericFacet )+
// Check precedence
	nonLitNodeConstraint	:=	nonLiteralKind ( stringFacet )*
		|	( stringFacet )+
	nonLiteralKind	:=	<IRI>
		|	<BNODE>
		|	<NONLITERAL>
	xsFacet	:=	stringFacet
		|	numericFacet
	stringFacet	:=	stringLength <INTEGER>
		|	<REGEXP>
	stringLength	:=	<LENGTH>
		|	<MINLENGTH>
		|	<MAXLENGTH>
	numericFacet	:=	numericRange numericLiteral
		|	numericLength <INTEGER>
	numericRange	:=	<MININCLUSIVE>
		|	<MINEXCLUSIVE>
		|	<MAXINCLUSIVE>
		|	<MAXEXCLUSIVE>
	numericLength	:=	<TOTALDIGITS>
		|	<FRACTIONDIGITS>
	shapeDefinition	:=	( extraPropertySet | <CLOSED> )* <LBRACE> ( tripleExpression )? <RBRACE> ( annotation )* semanticActions
	inlineShapeDefinition	:=	( extraPropertySet | <CLOSED> )* <LBRACE> ( tripleExpression )? <RBRACE>
	extraPropertySet	:=	<EXTRA> ( predicate )+
// Original:
// void tripleExpression() : {}
// {
//     oneOfTripleExpr()
// }
// 
// void oneOfTripleExpr() : {}
// {
//  	(LOOKAHEAD(2)
//       groupTripleExpr()
//     | multiElementOneOf()
//     )
// }
// 
// void multiElementOneOf() : {}
// {
//    	groupTripleExpr() (<VBAR> groupTripleExpr())+
// }
// 
// void groupTripleExpr() : {}
// {
//     ( LOOKAHEAD(2)
//    	  singleElementGroup()
//     | multiElementGroup()
//     )
// }
// 
// void singleElementGroup() : {}
// {
//   	unaryTripleExpr() (<SEMI_COLON>)?
// }
// 
// void multiElementGroup() : {}
// {
//   	unaryTripleExpr()
//      (LOOKAHEAD(2) <SEMI_COLON> unaryTripleExpr())+
//      (<SEMI_COLON>)?
// }

// ---- Improvement for LL(1)
	tripleExpression	:=	tripleExpressionClause ( <VBAR> tripleExpressionClause )*
	tripleExpressionClause	:=	unaryTripleExpr ( <SEMI_COLON> ( tripleExpressionClause )? )?
// ----
	unaryTripleExpr	:=	( <DOLLAR> tripleExprLabel )? ( tripleConstraint | bracketedTripleExpr )
		|	include
	bracketedTripleExpr	:=	<LPAREN> tripleExpression <RPAREN> ( cardinality )? ( annotation )* semanticActions
	tripleConstraint	:=	( senseFlags )? predicate inlineShapeExpression ( cardinality )? ( annotation )* semanticActions
	cardinality	:=	<STAR>
		|	<PLUS>
		|	<QMARK>
		|	<REPEAT_RANGE>
	senseFlags	:=	<CARAT>
	valueSet	:=	<LBRACKET> ( valueSetValue )* <RBRACKET>
// in https://github.com/shexSpec/grammar/blob/master/ShExDoc.g4
// valueSetValue   : iriRange
// 				| literalRange
// 				| languageRange
// 				| '.' (iriExclusion+ | literalExclusion+ | languageExclusion+)
// 				;

// void valueSetValue() : {}
// {
//     iriRange() | literalRange() | languageRange() | (LOOKAHEAD(2) exclusion())+
// }
// 
// void exclusion() : {}
// {
//   	<MINUS>
//     (
//         iri() | literal() | <LANGTAG>
//     ) (<TILDE>)?
// }
	valueSetValue	:=	iriRange
		|	literalRange
		|	languageRange
		|	<DOT> ( anyExclusion )+
// Better exclusion.
	anyExclusion	:=	<MINUS> ( iri ( <TILDE> )? | literal ( <TILDE> )? | <LANGTAG> ( <TILDE> )? )
// Original
// void iriRange() : {}
// {
//    iri() (<TILDE> ( exclusion())*)?
// }
	iriRange	:=	iri ( <TILDE> ( iriExclusion )* )?
	iriExclusion	:=	<MINUS> iri ( <TILDE> )?
	literalRange	:=	literal ( <TILDE> ( literalExclusion )* )?
	literalExclusion	:=	<MINUS> literal ( <TILDE> )?
	languageRange	:=	( <LANGTAG> ( <TILDE> ( languageExclusion )* )? | <AT> <TILDE> ( languageExclusion )* )
	languageExclusion	:=	<MINUS> <LANGTAG> ( <TILDE> )?
	include	:=	<AMP> tripleExprLabel
	annotation	:=	"//" predicate ( iri | literal )
	semanticActions	:=	( codeDecl )*
	codeDecl	:=	<PERCENT_CHAR> iri ( <CODE> | <PERCENT_CHAR> )
	literal	:=	rdfLiteral
		|	numericLiteral
		|	booleanLiteral
	predicate	:=	iri
		|	<RDF_TYPE>
// void datatype() : {}
// {
//     iri()
// }
	shapeExprLabel	:=	iri
		|	blankNode
	tripleExprLabel	:=	iri
		|	blankNode
// ------------------------- Terms
	booleanLiteral	:=	<TRUE>
		|	<FALSE>
	numericLiteral	:=	<INTEGER>
		|	<DECIMAL>
		|	<DOUBLE>
	rdfLiteral	:=	langString
		|	string ( "^^" datatype )?
	datatype	:=	iri
	string	:=	<STRING_LITERAL_LONG1>
		|	<STRING_LITERAL_LONG2>
		|	<STRING_LITERAL1>
		|	<STRING_LITERAL2>
	langString	:=	<LANG_STRING_LITERAL1>
		|	<LANG_STRING_LITERAL_LONG1>
		|	<LANG_STRING_LITERAL2>
		|	<LANG_STRING_LITERAL_LONG2>
	iri	:=	IRIREF
		|	prefixedName
	blankNode	:=	<BLANK_NODE_LABEL>
	prefixedName	:=	( <PNAME_LN> | <PNAME_NS> )
	IRIREF	:=	<IRIref>

DOCUMENT END
